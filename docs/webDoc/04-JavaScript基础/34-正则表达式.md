---
title: 34-正则表达式
publish: true
---

## 正则表达式简介

**定义**：正则表达式用于定义一些字符串的规则。

**==作用==**：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。

如果你想查看正则更多的内容，可以查阅官方文档关于 RegExp 这个内置对象的用法。

## 创建正则表达式的对象

### 方式一：使用构造函数创建正则表达式的对象

语法：

```javascript
var 变量 = new RegExp('正则表达式'); // 注意，参数是字符串

var 变量 = new RegExp('正则表达式', '匹配模式'); // 注意，两个参数都是字符串
```

备注：`RegExp`的意思是 **Regular expression**。使用 typeof 检查正则对象，会返回 object。

上面的语法中，既可以传一个==参数==，也可以传两个参数。

创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤：

- （1）创建正则表达式的对象 reg。

- （2）使用 reg 的==test()== 方法，判断指定字符串是否符合规则。

### 实际项目中遇到的错误

将字符串转为正则表达式

```js
上面这部分代码有什么错误？

let reg = /`${key}`/gi;
ChatGPT

上面的代码是有语法错误的。因为模板字符串中的变量应该使用${}语法，而不是用反引号拼接字符串。正确的写法应该是：

let reg = new RegExp(`${key}`, 'gi');
或者使用模板字符串简写的方式：

let reg = new RegExp(`${key}`, 'gi');
这将创建一个新的正则表达式对象，并将变量key的值作为正则表达式的模式。注意，使用正则表达式的构造函数（RegExp()）时，模式字符串应该被包含在双引号或单引号中，并传递一个标志字符串（例如 'gi'）来指定匹配模式。
```

**正则表达式的`test()`方法**：【重要】

```javascript
myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则
```

解释：使用`test()`这个方法可以用来检查一个字符串是否符合正则表达式的规则，**如果符合则返回 true，否则返回 false**。

我们来看看下面的例子。

**1、传一个参数时**：

构造函数 RegExp 中，可以只传一个参数。

代码举例：

```javascript
var reg = new RegExp('a'); // 定义一个正则表达式：检查一个字符串中是否含有 a

var str1 = 'qianguyihao';
var str2 = 'smyh';

// 通过 test()方法，判断字符串是否符合 上面定义的 reg 规则
console.log(reg.test(str1)); // 打印结果：true
console.log(reg.test(str2)); // 打印结果：false
```

注意，上面的例子中，我们是先定义了一个正则表达式的规则，然后通过正则表达式的`test()`方法来判断字符串是否符合之前定义的规则。

**2、传两个参数时**：匹配模式 <span style='color:#f00;'>【重要】</span>

构造函数 RegExp 中，也可以传两个参数。我们可以传递一个**匹配模式**作为第二个参数。这个参数可以是：

- `i` 忽略大小写。这里的 i 指的是 ignore。
- `g` 全局匹配模式。这里的 g 指的是 global。

代码举例：

```javascript
var reg = new RegExp('A', 'i');
var str = 'qiangu';

console.log(reg.test(str)); // 打印结果：true
```

### 方式二：使用字面量创建正则表达式

我们可以使用字面量来创建正则表达式。

语法：

```javascript
	var 变量 = /正则表达式/;  // 注意，这个语法里没有引号

	var 变量 = /正则表达式/匹配模式;  // 注意，这个语法里没有引号
```

代码举例：

```javascript
var reg = /A/i; // 定义正则表达式的规则：检查一个字符串中是否含有 a。忽略大小写。
var str = 'qiangu';

console.log(typeof reg); // 打印结果：object
console.log(reg.test(str)); // 打印结果：true
```

### 以上两种方式的对比

- 方式一：使用构造函数创建时，更加灵活，因为参数中还可以传递变量。

- 方式二：使用字面量的方式创建，更加简单。

代码举例：

```javascript
var reg = new RegExp('a', 'i'); // 方式一

var reg = /a/i; // 方式二
```

上面这两行代码的作用是等价的。

### 避坑指南：全局匹配 g 慎用 test()方法

对于非全局匹配的正则表达式，`test()`只会检测**是否存在某个目标字符串**（只要存在就为 true），多次检测的结果都相同。例如：

```javascript
const reg = /test/;
const str = '_test_test';

reg.test(str); // true
reg.test(str); // true
reg.test(str); // true
```

重点来了。

当设置全局标志 `/g` 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 `lastIndex` 属性的值**设置为上次匹配成功结果之后的第一个字符所在的位置**，下次匹配将从 `lastIndex` 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。

举例：（很重要的例子，看仔细）

```javascript
const reg = /test/g;
const str = '_test_test';

console.log(reg.test(str)); // true
console.log(reg.lastIndex); // 5

console.log(reg.test(str)); // true
console.log(reg.lastIndex); // 10

console.log(reg.test(str)); // false
console.log(reg.lastIndex); // 0
```

**总结**：

全局匹配模式`g`一般用于 `exec()`、`match()`、`replace()`等方法。

<u>全局匹配模式`g`如果用于 test()方法会有问题。因为 g 模式会生成一个`lastindex`参数来存储匹配最后一次的位置。</u>

参考链接：

- [JS 正则表达式全局匹配的那些坑](https://juejin.im/post/5de9bd5fe51d45582c27b6f3)

- [javascript 正则全局匹配 g 慎用 test 方法](https://blog.csdn.net/Leolu007/article/details/8576490)

## 正则表达式的简单语法

### 检查一个字符串中是否包含 a 或 b

**写法 1**：

```javascript
var reg = /a|b/;
```

解释：使用 `|` 表示`或`的意思。

**写法 2**：

```javascript
var reg = /[ab]/; // 跟上面的那行语法，是等价的
```

解释：这里的`[]`也是表示`或`的意思。

`[]`这个符号在正则还是比较常用的。我们接下来看几个例子。

### []表示：或

一些规则：

- `/[ab]/` 等价于 `/a|b/`：检查一个字符串中是否包含 **a 或 b**

- `/[a-z]/`：检查一个字符串那种是否包含**任意小写字母**

- `/[A-Z]/`：任意大写字母

- `/[A-z]/`：任意字母

- `/[0-9]/`：任意数字

- `/a[bde]c/`：检查一个字符串中是否包含 abc 或 adc 或 aec

### [^ ] 表示：除了

举例 1：

```javascript
var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容？
var str = 'acb';

console.log(reg.test(str)); // 打印结果：true
```

举例 2：（可以用来验证某字符串是否为 纯数字）

```javascript
var reg = /[^0-9]/; // 规则：字符串中，除了数字之外，还有没有其他的内容？
var str1 = '1991';
var str2 = '199a1';

console.log(reg.test(str1)); // 打印结果：false （如果字符串是 纯数字，则返回 false）
console.log(reg.test(str2)); // 打印结果：true
```

## 支持正则表达式的 String 对象的方法

String 对象的如下方法，是支持正则表达式的：

| 方法      | 描述                                                   | 备注 |
| :-------- | :----------------------------------------------------- | :--- |
| split()   | 将字符串拆分成数组                                     |      |
| search()  | 搜索字符串中是否含有指定内容，返回索引 index           |      |
| match()   | 根据正则表达式，从一个字符串中将符合条件的内容提取出来 |      |
| replace() | 将字符串中的指定内容，替换为新的内容并返回             |      |
| trim()    | 去除字符串两端的空格                                   |      |

下面来分别介绍和举例。

### split()

`split()`：将一个字符串拆分成一个数组。可以接受一个正则表达式作为参数。

备注：关于`split()`更详细的用法，可以看之前的关于《内置对象：String》这篇文章。

**正则相关的举例**：根据任意字母，将字符串拆分成数组。

代码实现：（通过正则）

```javascript
var str = '1a2b3c4d5e6f7g';

var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字母
console.log(result);
```

打印结果：

```json
["1", "2", "3", "4", "5", "6", "7", ""]
```

### search()

`search()`：搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引；否则返回-1。

`search()`方法可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串。`serach()`只会查找第一个，即使设置全局匹配也没用。

**举例**：

```javascript
var str = 'hello abc hello aec afc';
/*
 * 搜索字符串中是否含有abc 或 aec 或 afc
 */
result = str.search(/a[bef]c/);
console.log(result); // 打印结果：6
```

### match()

`match()`：根据正则表达式，从一个字符串中将符合条件的内容提取出来，封装到一个数组中返回（即使只查询到一个结果）。

**注意**：默认情况下，`match()`方法只会找到**第一个**符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为**全局匹配**模式，这样就会匹配到所有的内容，并以**数组**的形式返回。

另外，我们可以为一个正则表达式设置多个匹配模式，且匹配模式的顺序无所谓。

**代码举例**：

```javascript
var str = '1a2a3a4a5e6f7A8B9C';

var result1 = str.match(/[a-z]/); // 找到符合要求的第一个内容，然后返回
var result2 = str.match(/[a-z]/g); // 设置为“全局匹配”模式，匹配字符串中 所有的小写字母
var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，匹配字符串中 所有的字母（忽略大小写）

console.log(result1); // 打印结果：["a"]
console.log(result2); // 打印结果：["a", "a", "a", "a", "e", "f"]
console.log(result3); // 打印结果：["a", "a", "a", "a", "e", "f", "A", "B", "C"]
```

**总结**：

match()这个方法还是很实用的，可以在一个很长的字符串中，提取出**有规则**的内容。这不就是爬虫的时候经常会遇到的场景么？

### replace()

`replace()`：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。

语法：

```javascript
	新的字符串 = str.replace(被替换的内容，新的内容);
```

参数解释：

- 被替换的内容：可以接受一个正则表达式作为参数。

- 新的内容：默认只会替换第一个。如果需要替换全部符合条件的内容，可以设置正则表达式为**全局匹配**模式。

代码举例：

```javascript
//replace()方法：替换
var str2 = 'Today is fine day,today is fine day !!!';

console.log(str2);
console.log(str2.replace('today', 'tomorrow')); //只能替换第一个today
console.log(str2.replace(/today/gi, 'tomorrow')); //这里用到了正则，且为“全局匹配”模式，才能替换所有的today
```

**replace 高级用法**

```js
str.replace(/\b[a-z]/g, (s) => {
	s.toUpperCase();
}); //回调函数的参数表示搜索到的字符
```

## 常见正则表达式举例

### 检查一个字符串是否是一个合法手机号

手机号的规则：

- 以 1 开头（`^1` 表示 1 开头 , `[^1]`表示非 1 或除了 1）

- 第二位是 3~9 之间任意数字

- 三位以后任意 9 位数字

正则实现：

```javascript
var phoneStr = '13067890123';

var phoneReg = /^1[3-9][0-9]{9}$/;

console.log(phoneReg.test(phoneStr));
```

**备注**：如果在正则表达式中同时使用`^`和`$`符号，则要求字符串必须完全符合正则表达式。

### 去掉字符串开头和结尾的空格

正则实现：

```javascript
str = str.replace(/^\s*|\s*$/g, '');
```

解释如下：

```javascript
str = str.replace(/^\s*/, ''); //去除开头的空格

str = str.replace(/\s*$/, ''); //去除结尾的空格
```

### 判断字符串是否为电子邮件

正则实现：

```javascript
var emailReg = /^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;

var email = 'abchello@163.com';

console.log(emailReg.test(email));
```

---

### 正则匹配模式

|    匹配模式    | 相关说明                                                                                                 | 举例                                                                                                                                                                                           |
| :------------: | :------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |
|     [abc]      | 匹配的字符类信息                                                                                         | > `"Some Text".match(/[otx]/g); ` //['o','x','t'];                                                                                                                                             |
|     [a-z]      | [a-z]就相当于[abcd],[a-z]就表示我们要匹配所有的小写字母，而[a-zA-Z0-9_]就是匹配所有的 字母、数字及下划线 | > `"Some Text".match(/[a-z]/g); `//['o','m','e','e','x','t'];                                                                                                                                  |
|     [^abc]     | 匹配所有不属于限定范围内的字符                                                                           | > `"Some Text".match(/[^a-z]/g);`　　//['S',' ','T'];                                                                                                                                          |
|      a\|b      | 这里匹配的是 a 或者 b                                                                                    | > `"Some Text".match(/a                                                                                                                                                                        | b/g);` //null |
|     a(?=b)     | 匹配所有后面紧跟着 b 的 a 的信息                                                                         | > `"Some Text".match(/So(?=me)/g);`　 //["So"] 　> `"Some Text".match(/Some(?=Tex)/g);`　 //null                                                                                               |
|     a(?!b)     | 匹配所有后面不跟着 b 的 a 的信息                                                                         | > `"Some Text".match(/Some(?!Tex)/g);`　 //["some"]                                                                                                                                            |
|       \        | 反斜杠主要用于帮助我们匹配一些模式文本中的特殊字符                                                       | > `"R2-D2".match(/[2\-3]/g);　` //["2","-","2"]                                                                                                                                                |
| \n \r \f \t \v | 换行符 　　回车符 　　换页符 　　横向制表符 　　纵向制表符                                               |                                                                                                                                                                                                |
|     ==\s==     | 这是匹配的空白符，包含上面五个转义字符                                                                   | > `"R2\n D2".match(/\s/g);`　 //["\n"," "]                                                                                                                                                     |
|     ==\S==     | 匹配除空白符以外的内容，就相当于 `[^\s]`                                                                 |                                                                                                                                                                                                |
|     ==\w==     | 匹配所有的字母、数字和下划线，相当于 [A-Za-z0-9_]                                                        |                                                                                                                                                                                                |
|       \W       | 刚好与\w 相反                                                                                            |                                                                                                                                                                                                |
|     ==\d==     | 匹配所有的数字类信息 相当于 [0-9]                                                                        |                                                                                                                                                                                                |
|       \D       | 刚好与\d 相反                                                                                            |                                                                                                                                                                                                |
|     ==\b==     | 匹配一个单词的边界，例如空格和标点符号                                                                   | /\b[a-z]/g 结合使用                                                                                                                                                                            |
|       \B       | 刚好与\b 相反                                                                                            |                                                                                                                                                                                                |
|      [\b]      | 匹配的是退格键符（Backspace）                                                                            |                                                                                                                                                                                                |
|       \0       | 这里匹配的是 null                                                                                        |                                                                                                                                                                                                |
|     \uoooo     | 这里匹配的是一个 unicode 字符，并且是一个四位 16 进制数来表示，                                          | >`"CTOH".match(/\u0441\u0442\u943E/)　`　//["CTO"]                                                                                                                                             |
|      \x00      | 这里匹配的是一个字符，该字符的编码是一个两位十六进制数来表示的                                           | > `"dude".match(/x64/g);`　　// ["d","d"]                                                                                                                                                      |
|      `^`       | 匹配字符串的开头部分，如果设置了 m，那就是匹配每一行的开头                                               |                                                                                                                                                                                                |
|      `$`       | 匹配字符串的结尾部分，如果设置了 m，那就是匹配每一行的结尾                                               |                                                                                                                                                                                                |
|      `.`       | 这里 匹配的是除了换行符以为的任何字符                                                                    |                                                                                                                                                                                                |
|      `*`       | 这里匹配的是模式中间出现 0**次或者多次**的内容。例如/.\*/可以匹配任何内容                                |                                                                                                                                                                                                |
|      `？`      | 匹配模式中间出现**0 次或者 1 次**的内容                                                                  | > `"anything".match(/ng?/g);` //['n', 'ng']                                                                                                                                                    |
|      `+`       | 这里匹配的是模式中间**至少出现一次**或者多次的内容                                                       | >`"R2-D2" and C-3PO".match("/[a-z]+/gi"); `　//["R","D","and","C","po"]                                                                                                                        |
|      {n}       | 匹配模式中出现 n 次的内容                                                                                | > `"regular expression".match(/\b\w{3}/g);`　　　//["reg","exp"]                                                                                                                               |
|   {min,max}    | 匹配模式中间出现次数在 min 和 max 之间的信息 ，如果省略了 max，则意味着没有最多次数                      | >`"goooooooooole".match(/o{2 , }/g);`　　//["oo","oo","oo","oo","oo"]                                                                                                                          |
|   (pattern)    | 捕获模式 `$n`表示第几个捕获组(也就是括号)                                                                | >`"regular expression".replace(/(r)/g , '$1.$1' );`　　　　 //`'r.regular.r expr.ression'`　　　　　<br/>>`"regular expression".replace(/(r)(e)/g , "$2.$1");`　　 // `'e.rgular expe.rssion'` |
|  (?:pattern)   | 这不是捕获模式,不能用$1,$2 等参数来记录匹配串                                                            | >`"regular expression".match(/(?:r)(e)/g , '$1.$1' );`　//eegular expeession                                                                                                                   |

### 正则表达式的捕获组``

正则表达式的捕获组是一种用于从匹配的文本中提取特定部分的机制。通过在正则表达式中使用括号 `( )`，你可以将模式的一部分标记为一个捕获组。这允许你在匹配成功后，从文本中提取、引用或进一步处理这些捕获的部分。

例如，考虑正则表达式 `/(\d{2})-(\d{2})-(\d{4})/`，这个表达式用于匹配日期的格式，如 "08-08-2023"。在这个表达式中，有三个捕获组，分别是 `\d{2}`、`\d{2}` 和 `\d{4}`，它们分别匹配日期中的月、日和年。当这个表达式与文本匹配时，你可以使用 `\1`、`\2` 和 `\3` 来获取对应捕获组的值。

捕获组不仅可以用于提取数据，还可以在正则表达式的模式中进行进一步的操作，例如在匹配中使用捕获组的值作为替换文本。

## **RegexBuddy 4**软件用法

![1678866923112]( D:/html5_folder/my-webdoc/图床/1678866923112.png)

---

## 一、校验数字的表达式

\1. 数字：^[0-9]\*$

\2. n 位的数字：^\d{n}$

\3. 至少 n 位的数字：^\d{n,}$

\4. m-n 位的数字：^\d{m,n}$

\5. 零和非零开头的数字：^(0|[1-9][0-9]\*)$

\6. 非零开头的最多带两位小数的数字：^([1-9][0-9]\*)+(.[0-9]{1,2})?$

\7. 带 1-2 位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$

\8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$

\9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

\10. 有 1~3 位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

\11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]\*$

\12. 非零的负整数：^\-[1-9][]0-9″_$ 或 ^-[1-9]\d_$

\13. 非负整数：^\d+$ 或 ^[1-9]\d\*|0$

\14. 非正整数：^-[1-9]\d\*|0$ 或 ^((-\d+)|(0+))$

\15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

\16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

\17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]_[1-9][0-9]_)|([0-9]_[1-9][0-9]_\.[0-9]+)|([0-9]_[1-9][0-9]_))$

\18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]_[1-9][0-9]_)|([0-9]_[1-9][0-9]_\.[0-9]+)|([0-9]_[1-9][0-9]_)))$

\19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

## 二、校验字符的表达式

\1. 汉字：^[\u4e00-\u9fa5]{0,}$

\2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$

\3. 长度为 3-20 的所有字符：^.{3,20}$

\4. 由 26 个英文字母组成的字符串：^[A-Za-z]+$

\5. 由 26 个大写英文字母组成的字符串：^[A-Z]+$

\6. 由 26 个小写英文字母组成的字符串：^[a-z]+$

\7. 由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$

\8. 由数字、26 个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$

\9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

\10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

\11. 可以输入含有^%&’,;=?$\”等字符：[^%&’,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+

## 三、特殊需求表达式

\1. Email 地址：^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+

\2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

\3. InternetURL：[a-zA-z]+://[^\s]_ 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]_)?$

\4. 手机号码：^1[3-9]\d{9}$

\5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$

\6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}

\7. 身份证号(15 位、18 位数字)：^\d{15}|\d{18}$

\8. 短身份证号码(数字、字母 x 结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

\9. 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

\10. 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

\11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=._\d)(?=._[a-z])(?=.\*[A-Z]).{8,10}$

\12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}

\13. 一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?[1-9]|1[0-2])$

\14. 一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

\15. 钱的输入格式：

\16. 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]\*$

\17. 2.这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]\*)$

\18. 3.一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]\*)$

\19. 4.这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

\20. 5.必须说明的是,小数点后面至少应该有 1 位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$

\21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

\22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})\*(.[0-9]{1,2})?$

23 8.1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})\*)(.[0-9]{1,2})?$

\24. 备注：这就是最终结果了,别忘了”+”可以用”\*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

\25. xml 文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

\26. 中文字符的正则表达式：[\u4e00-\u9fa5]

\27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))

\28. 空白行的正则表达式：\n\s\*\r (可以用来删除空白行)

\29. HTML 标记的正则表达式：<(\S*?)[^>]*>._?</\1>|<._? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

\30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

\31. 腾讯 QQ 号：[1-9][0-9]{4,} (腾讯 QQ 号从 10000 开始)

\32. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为 6 位数字)

\33. IP 地址：\d+\.\d+\.\d+\.\d+ (提取 IP 地址时有用)

\34. IP 地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

原文：http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html
